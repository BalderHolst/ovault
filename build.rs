fn main() {
    #[cfg(feature = "python")]
    {
        use std::path::PathBuf;
        let root = PathBuf::from(concat!(env!("CARGO_MANIFEST_DIR"), "/src"));
        let out_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join(format!("{}.pyi", env!("CARGO_PKG_NAME")));
        if out_path.exists() {
            std::fs::remove_file(&out_path).unwrap();
        }
        stubify::stubify(root, &out_path);
    }
}

#[cfg(feature = "python")]
mod stubify {
    use std::{
        fs::{self, OpenOptions},
        io::Write,
        path::PathBuf,
    };

    use quote::ToTokens;
    use syn::{self, ItemStruct, Visibility};

    struct PyClass {
        name: String,
        doc: Vec<String>,
        rust_file: PathBuf,
    }

    impl ToString for PyClass {
        fn to_string(&self) -> String {
            let mut meta = String::new();

            meta.push_str(&format!("# {}\n", self.rust_file.display()));

            let mut body = String::new();

            if !self.doc.is_empty() {
                body.push_str("    \"\"\"\n");
                for doc in &self.doc {
                    body.push_str(&format!("    {}\n", doc));
                }
                body.push_str("    \"\"\"\n");
            }

            if body.is_empty() {
                body.push_str("    pass");
            }

            format!("{}class {}:\n{}", meta, self.name, body)
        }
    }

    struct Stubifier {
        classes: Vec<PyClass>,
    }

    impl Stubifier {
        const STUB_MSG: &str = "\
# This file is generated by build.rs.
# Do not edit it manually.

";
        fn new() -> Self {
            Self { classes: vec![] }
        }

        fn handle_struct(&mut self, path: &PathBuf, s: ItemStruct) {
            let Visibility::Public(_) = s.vis else {
                return;
            };

            let mut is_pyclass = false;
            let mut docstring = vec![];

            for attr in &s.attrs {
                if attr.to_token_stream().to_string().contains("pyclass") {
                    is_pyclass = true;
                }

                match &attr.meta {
                    syn::Meta::Path(_path) => {}
                    syn::Meta::List(_meta_list) => {}
                    syn::Meta::NameValue(meta_name_value) => {
                        if !meta_name_value.path.is_ident("doc") {
                            continue;
                        }
                        docstring.push(
                            meta_name_value
                                .value
                                .to_token_stream()
                                .to_string()
                                .strip_prefix("\"")
                                .unwrap()
                                .strip_suffix("\"")
                                .unwrap()
                                .trim()
                                .to_string(),
                        );
                    }
                }
            }

            if !is_pyclass {
                return;
            }

            self.classes.push(PyClass {
                name: s.ident.to_string(),
                doc: docstring,
                rust_file: path
                    .strip_prefix(concat!(env!("CARGO_MANIFEST_DIR"), "/src"))
                    .unwrap()
                    .to_path_buf(),
            });
        }

        fn collect_classes(&mut self, path: &PathBuf) {
            for entry in std::fs::read_dir(path).unwrap() {
                let entry = entry.unwrap();
                let path = entry.path();
                if path.is_dir() {
                    self.collect_classes(&path);
                } else {
                    let ext = path.extension().unwrap();
                    if ext != "rs" {
                        continue;
                    }
                    let content = std::fs::read_to_string(&path).unwrap();
                    let ast = syn::parse_file(&content).unwrap();
                    for item in ast.items {
                        match item {
                            syn::Item::Struct(s) => self.handle_struct(&path, s),
                            _ => {}
                        }
                    }
                }
            }
        }

        fn write(&self, out_path: &PathBuf) {
            if !fs::exists(out_path).unwrap() {
                let path = PathBuf::from(out_path);
                fs::create_dir_all(path.parent().unwrap()).unwrap();
                fs::write(out_path, Self::STUB_MSG).unwrap();
            }

            let stub = self
                .classes
                .iter()
                .map(PyClass::to_string)
                .collect::<Vec<String>>()
                .join("\n\n");

            OpenOptions::new()
                .write(true)
                .append(true)
                .create(true)
                .open(out_path)
                .unwrap()
                .write_all(stub.as_bytes())
                .unwrap();
        }
    }

    pub fn stubify(path: PathBuf, out_path: &PathBuf) {
        let stubifier = &mut Stubifier::new();
        stubifier.collect_classes(&path);
        stubifier.write(out_path);
    }
}
